---
title: "revpref"
output: 
  pdf_document:
    citation_package: natbib
author: "Khushboo Surana"
date: "6 April, 2021"
bibliography: "H:/Desktop/reference.bib"
vignette: >
  %\VignetteIndexEntry{revpref}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

The goal of revpref is to provide a set of tools to test whether consumer demand data satisfy a number of revealed preference axioms; compute measures of goodness-of-fit when the data is inconsistent with the axioms; and compute power against uniformly random behavior.

Utility maximization hypothesis 

# Revealed Preference

## Axioms of revealed preference
We assume that the data set consists of $T$ observations of prices and quantities of $N$ consumption categories. Let $p_t = (p^1_t, p^2_t,\cdots,p^N_t) \in \mathbb{R}^N_{++}$ and $q_t = (q^1_t, q^2_t,\cdots,q^N_t) \in \mathbb{R}^N_{+}$ be the vectors of prices and quantities corresponding to observation $t \in \lbrace 1,2,\cdots, T \rbrace$. We assume that all prices are strictly positive and that all quantities are non-negative. The data set $S = \lbrace (p_t,q_t), t = 1,2,\cdots,T \rbrace$ represents the set of observations. 

*Definition 1:* A data set $S = \lbrace (p_t,q_t), t = 1,2,\cdots,T \rbrace$ is rationalizable by a well-behaved utility function $u$ if for each observation $t$
$$ u(q_t) \geq u(q) \text{ for all } q \text{ with } p_t'q \leq p_t'q_t$$
To define the rationalizability conditions we need the following concepts. We say that $q_t$ is directly revealed preferred to $q_s$ (denoted as $q_tR^Dq_s$) if $p_t'q_t \geq p_t'q_s$. Intuitively, this means that the consumer reveals his preference for $q_t$ over $q_s$ if he purchases $q_t$ when $q_s$ was within the budget. Similarly, we say that $q_t$ is strictly directly revealed preferred to $q_s$ (denoted as $q_tP^Dq_s$) if $p_t'q_t > p_t'q_s$. Next, we say that $q_t$ is (indirectly) revealed preferred to $q_s$ (denoted as $q_tRq_s$) if there exists a sequence of observations $(t,u,v,\cdots,w,s)$ such that $q_t R^D q_v, q_v R^D q_w, \cdots, q_w R^D q_s$. Put differently, $R$ is the transitive closure of $R^D$. Below, we define the three axioms of revealed preference that are considered for often used to verify consistency of a data with utility maximization hypothesis

* *WARP:* A dataset $S$ satisfies WARP if and only if for each pair of distinct bundles $q_t$ and $q_s$, if $q_t R^D q_s$, then it is not the case that $q_s R^D q_t$.

* *SARP:* A dataset $S$ satisfies SARP if and only if for each pair of distinct bundles $q_t$ and $q_s$, if $q_t R q_s$, then it is not the case that $q_s R^D q_t$.

* *GARP:* A dataset $S$ satisfies GARP if and only if for each pair of distinct bundles $q_t$ and $q_s$, if $q_t R q_s$, then it is not the case that $q_s P^D q_t$.

The first axiom, proposed by @samuelson1938note, requires that the direct revealed preference relation be asymmetric. However, by construction, the direct revealed preference relation may be incomplete. This means that if $q_tR^Dq_v$ and $q_vR^Dq_s$, this does not necessarily imply that $q_tR^Dq_s$. By considering the transitive closure of the direct revealed preference relation, the revealed preference relation ($R$) ensures that the preference relation is complete. @houthakker1950revealed showed that data consistency with SARP is a necessary and sufficient condition for maximizing a continuous, strictly increasing and strictly concave utility function. As such, data consistency with WARP is a necessary condition for the consistency with SARP. Moreover, @rose1958consistency showed that WARP and SARP are equivalent when there are only two consumption categories ($N=2$). Finally, @varian1982nonparametric built on @afriat1967construction and showed that data consistency with GARP is a necessary and sufficient condition for maximizing a continuous, strictly increasing and concave utility function. Intuitively, GARP requires that if bundle $q_t$ is revealed preferred over $q_s$, then $q_s$ can not be more expensive than $q_t$. GARP generalizes SARP by allowing demand correspondences and indifference curves with flat portions.


*Weakening the sharp conditions:* The three axioms shown above are sharp in that a data set either satisfy the conditions or reject it. If a dataset is inconsistent, one may consider weakening the sharp restrictions. To consider the weaker conditions, we can define the axioms at any efficiency level $e in [0,1]$. First, the direct and indirect revealed preference relation can be modified in the following way. We say that $q_t$ is directly revealed preferred to $q_s$ at efficiency level $e$ (denoted as $q_tR^D_eq_s$) if $p_t'q_s \leq ep_t'q_t$. If the inequality is strict, we say that $q_t$ is strictly directly revealed preferred to $q_s$ (denoted as $q_sp^D_eq_s$). Finally, the transitive closure of $R^D_e$ is used to define the (indirect) revealed preference relation at efficiency level $e$ (denoted as $R_e$). Essentially, defining the preference relations at efficiency level $e$, weakens the strict relation ($R^D, P^D, R$) because now a bundle $q_t$ is said to be preferred over $q_s$ only if $q_s$ was available when the budget at $t$ is decreased by a fraction $(1-e)$. The weakened revealed preference relations can be used to define slightly modified axioms as follows.

* *eWARP:* A dataset $S$ satisfies WARP at an efficiency level $e$ if and only if for each pair of distinct bundles $q_t$ and $q_s$, if $q_t R^D_e q_s$, then it is not the case that $q_s R^D_e q_t$.

* *eSARP:* A dataset $S$ satisfies SARP at an efficiency level $e$ if and only if for each pair of distinct bundles $q_t$ and $q_s$, if $q_t R_e q_s$, then it is not the case that $q_s R^D_e q_t$.

* *eGARP:* A dataset $S$ satisfies GARP at an efficiency level $e$ if and only if for each pair of distinct bundles $q_t$ and $q_s$, if $q_t R_e q_s$, then it is not the case that $q_s P^D_e q_t$.

Clearly, if $e=1$ then eWARP, eSARP, and eGARP coincide with WARP, SARP, and GARP. On the other hand if $e = 0$, then no preference relation is established, so any data set satisfies the axioms at efficiency level 0. In general, if a dataset satisfies any axiom at efficiency level $e$, then it will satisfy the axiom for any efficiency level $e' \leq e$. 


## Goodness-of-fit

As an alternative to testing consistency with utility maximizing behavior, one can look at how far the demands are to being rationalizable (@varian1990goodness). 


### Critical Cost Efficieny Index

One of the popular ways to calculate the degree to which a data set violates the axioms is to use @afriat1967construction's Critical Cost Efficiency Index (CCEI). The CCEI is defined as the highest value of $e$ such that a data set still satisfies eGARP. Formally, the CCEI solves the following
$$ e^* = \sup \lbrace e \in [0,1] \text{ such that the data set statisfies eGARP}\rbrace.$$
A higher value of CCEI implies that the data is closer to satisfying the strict GARP conditions. @varian1990goodness
proposed using the CCEI as a measure of goodness-of-fit in terms of the fraction of expenditures that are allowed to be wasted while the data set is still consistent with utility maximizing behavior.

### Money Pump Index

More recently @echenique2011money

# Installation

You can install the released version of revpref from [CRAN](https://CRAN.R-project.org) with:

``` r
install.packages("revpref")
```

And the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("ksurana21/revpref")
```
# Example

This example shows you how to use the functions provided within this package. All the functions take as their two main (required) argument $T \times N$  matrices of prices $p$ and quantities $q$. 

```{r example}
# Load
library(revpref)

# Define a price matrix
p = matrix(c(4,4,4,1,9,3,2,8,3,1,8,4,3,1,9,3,2,8,8,4,1,4,1,8,9,3,1,8,3,2),
           nrow = 10, ncol = 3, byrow = TRUE)
print(p)

# Define a quantity matrix
q = matrix(c( 1.81,0.19,10.51,17.28,2.26,4.13,12.33,2.05,2.99,6.06,5.19,
              0.62,11.34,10.33,0.63,4.33,8.08,2.61,4.36,1.34, 9.76,1.37,36.35,
              1.02,3.21,4.97,6.20,0.32,8.53,10.92), nrow = 10, ncol = 3, byrow = TRUE)
print(q)

# Test consistency with WARP and compute the number of WARP violations
warp(p,q)

# Test consistency with SARP and compute the number of SARP violations
sarp(p,q)

# Test consistency with GARP and compute the number of GARP violations
garp(p,q)

# Compute the Critical Cost Efficiency Index (CCEI)
ccei(p,q)

# Compute bounds on the Money Pump Index (MPI)
mpi(p,q)

# Compute Bronars power index
bronars(p,q,1000)

```

You'll still need to render `README.Rmd` regularly, to keep `README.md` up-to-date. `devtools::build_readme()` is handy for this. You could also use GitHub Actions to re-render `README.Rmd` every time you push. An example workflow can be found here: <https://github.com/r-lib/actions/tree/master/examples>.

